========================
Compass Plugin Reference
========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

.. _plugins-roles:

Plugin Roles
------------

The role of your plugin dictates where it fits inside of |compass|. Each
role represents a different area of the UI within which your plugin
exists.

The 5 available roles for a plugin are:

- :ref:`Instance.Tab <plugin-ref-instance-tabs>`
- :ref:`Header.Item <plugin-ref-header-items>`
- :ref:`Database.Tab <plugin-ref-database-tabs>`
- :ref:`Collection.Tab <plugin-ref-collection-tabs>`
- :ref:`CollectionHUD.item <plugin-ref-collectionhud-items>`

.. _plugin-ref-instance-tabs:

Instance Tabs
~~~~~~~~~~~~~

This role provides the option to add a new tab at the instance level,
accessible by clicking the :guilabel:`Home Icon` for your cluster at
the top-left of the |compass| window. Currently, the two Instance Tabs
in |compass| are :guilabel:`Databases` and :guilabel:`Performance`.

.. figure:: /images/compass/instance-tab.png

The Instance Tabs role supports the following options:

.. list-table::
   :header-rows: 1

   * - **Field**

     - **Type**

     - **Required / Optional**

     - **Description**

   * - Component

     - String

     - Required

     - The react component

   * - Name

     - String

     - Required

     - The name of the tab

   * - Order

     - Integer

     - Optional

     - From 1-n, the order this tab appears in the tab list

.. _plugin-ref-header-items:

Header Items
~~~~~~~~~~~~

Header items display global information shown on every page of |compass|.
These items exist at the top of the application and are shown next to
the hostname.

.. figure:: /images/compass/header-item.png

.. tip ::

   Since these items are given high visual hierarchy, they should be
   both important and universally relevant.

   The available space for header items is limited. If you are looking
   to display larger blocks of information, you might consider waiting
   until the user presses a provided icon or button to reveal the
   item(s).

The Header Items role supports the following options:

.. list-table::
  :header-rows: 1

  * - **Field**

    - **Type**

    - **Required / Optional**

    - **Description**

  * - Component

    - String

    - Required

    - The react component

  * - Name

    - String

    - Required

    - The name of the tab

  * - Alignment

    - String

    - Optional

    - Choose ``right`` (default) or ``left`` to indicate how the
      heading will be aligned.

  * - Order

    - Integer

    - Optional

    - From 1-n, the order this item appears in the heading list from outside to inside

.. _plugin-ref-database-tabs:

Database Tabs
~~~~~~~~~~~~~

This role provides the option to add a new tab at the database level.
Currently, the only database tab in |compass| is :guilabel:`Collections`,
which displays a list of collections within the selected database.

.. figure:: /images/compass/database-tab.png

The Database Tabs role supports the following options:

.. list-table::
   :header-rows: 1

   * - **Field**

     - **Type**

     - **Required / Optional**

     - **Description**

   * - Component

     - String

     - Required

     - The react component

   * - Name

     - String

     - Required

     - The name of the tab

   * - Order

     - Integer

     - Optional

     - The order this tab appears in the tab list, from 1-n.

.. _plugin-ref-collection-tabs:

Collection Tabs
~~~~~~~~~~~~~~~

This role provides the option to add a new tab at the collection level.
Currently, the following collection tabs exist within |compass|:

- Documents
- Schema
- Explain Plan
- Indexes
- Validation
- Charts

.. figure:: /images/compass/collection-tab.png

The Collection Tabs role supports the following options:

.. list-table::
   :header-rows: 1

   * - **Field**

     - **Type**

     - **Required / Optional**

     - **Description**

   * - Component

     - String

     - Required

     - The react component

   * - Name

     - String

     - Required

     - The name of the tab

   * - Order

     - Integer

     - Optional

     - The order this tab appears in the tab list, from 1-n

   * - minimumServerVersion

     - Decimal

     - Optional

     - The minimum server version required to use the component

.. _plugin-ref-collectionhud-items:

CollectionHUD Items
~~~~~~~~~~~~~~~~~~~

This role exists at the collection level, displaying information in the
top-right corner of the collection GUI. CollectionHUD items display
numerical information relevant to the collection currently being viewed
by the user. Currently, |compass| uses this space to show a count, total
size, and average size of documents and indexes in a collection.

.. figure:: /images/compass/collection-hud.png

.. tip ::

   The information shown by this role is meant to be supplemental. It
   should not distract the user from the content of the collection
   tabs. As such, it is recommended to keep the information in this
   role text-based, and refrain from visual cues.

The CollectionHUD Items role supports the following options:

.. list-table::
   :header-rows: 1

   * - **Field**

     - **Type**

     - **Required / Optional**

     - **Description**

   * - Component

     - String

     - Required

     - The react component

   * - Name

     - String

     - Required

     - The name of the tab

   * - Order

     - Integer

     - Optional

     - From 1-n, the order of the item going from left to right

Writing Your Plugin
-------------------

|compass| plugins are written in ReactJS, which is comprised of
:ref:`stores <plugins-stores>`, :ref:`actions <plugins-actions>`
and :ref:`components <plugins-components>`.

- Stores keep track of state information and pass that information to
  components.
- Components receive and render information from the store to the user
  interface.
- Actions are how components with the store to trigger changes.

The following diagram illustrates how these pieces interact with one
another:

.. figure:: /images/compass/react-diagram.png

.. _plugins-stores:

Stores
~~~~~~

Stores are Reflux stores which hold the application state. Each
plugin manages its own state. A plugin can listen to state changes of
other stores and have its state changes listened to by others. The flow
of data through the application must only happen in a single direction.
In order to enforce this notion:

- :ref:`Actions <plugins-actions>` should be listened to by
  :ref:`stores <plugins-stores>` and
- stores should be subscribed to by
  :ref:`components <plugins-components>`.

Defining Stores
~~~~~~~~~~~~~~~

.. note::

   |compass| is tied to Reflux 0.4.1, so stores need to be defined
   using the Reflux 0.4.1 syntax. For details on creating data stores
   in Reflux 0.4.1, see
   `this page <https://github.com/reflux/refluxjs/tree/e34c2b7fb9199062cc587f883aeb1be233a3ef25#creating-data-stores>`_.


.. optional::

   You can use the *Reflux State Mixin* package to make the store
   behave more like a React component. For more information on this
   package, see
   `here <https://www.npmjs.com/package/reflux-state-mixin>`_.

To allow a store listen to a store in another plugin, the store must
define an ``onActivated`` method to ensure that all plugins have been
loaded before loading it from the application registry.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      import Reflux from 'reflux';
      import StateMixin from 'reflux-state-mixin';
      import Actions from 'actions';
      
      const MyStore = Reflux.createStore({
      
        mixins: [StateMixin.store],
      
        listenables: Actions,
      
        /**
         * return the initial store state
         */
        getInitialState: function() {
          return { connected: false };
        },
      
        /**
         * called when all plugins are activated. Subscribe to external stores here.
         */
        onActivated: function(appRegistry) {
          appRegistry.getStore('ExternalStore').listenTo(this.handleExternalChange.bind(this));
          appRegistry.on('data-service-connected', this.onConnected.bind(this));
        },
      
        /**
         * called when a connection has been established (or failed to establish).
         */
        onConnected: function(error, dataService) {
          if (!error) {
            dataService.command({ ping: 1 }, (err, result) => {
              if (!err) {
                this.setState({ connected: true });   // this triggers the store
              }
            });
          }
        },
      
        handleExternalChange(extState) {
          // Do something here.
        }
      });
      
      export default MyStore;
      export { MyStore };

Registering Stores
~~~~~~~~~~~~~~~~~~

If a plugin wants to use a store in another plugin or register one for
others to use, the store can be added to the application registry.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      import MyStore from 'stores';

      const activate(appRegistry) => {
         appRegistry.registerStore('MyPlugin.MyStore', MyStore);
      };

.. _plugins-actions:

Actions
~~~~~~~

Actions in a plugin are events that happen when a user performs an
action. For example, these can be button clicks, link clicks or text
entry to name a few.

Actions are defined using Reflux. Stores are the objects that listen
to the actions.

Defining Actions
~~~~~~~~~~~~~~~~

For information on defining actions and code examples, see the
`RefluxJS Documentation <https://github.com/reflux/refluxjs/tree/e34c2b7fb9199062cc587f883aeb1be233a3ef25#creating-actions>`_.

Registering Actions
~~~~~~~~~~~~~~~~~~~

To allow a plugin to use an action from another plugin or register
one of its own actions for other plugins to use, you must add the
target action to the application registry. The common pattern is to
define all the actions in a single object and register them all at
once.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const Actions = Reflux.createActions([
         'buttonClicked',
         'formSubmitted'
       ]);

       const activate(appRegistry) => {
         appRegistry.registerAction('MyPlugin.Actions', Actions);
       };

Listening to Actions
~~~~~~~~~~~~~~~~~~~~

In order to ensure that the flow of data through the application only
happens in a single direction, :ref:`stores <plugins-stores>` are the
only object type which should be listening to actions. A store can
listen to both its own plugin's actions as well as the actions of other
plugins.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const Actions = require('../actions');

      const MyPluginStore = Reflux.createStore({

        init: function() {
          Actions.buttonClicked.listenTo(this.handleButtonClicked.bind(this));
        },

        onActivated: function(appRegistry) {
          const actions = appRegistry.getAction('MyPlugin.Actions');
          actions.formSubmitted.listenTo(this.handleFormSubmitted.bind(this));
        },

        handleButtonClicked: function() {
          // Do something
        },

        handleFormSubmitted: function() {
          // Do something
        }
      });

.. _plugins-components:

Components
~~~~~~~~~~

Components in a plugin make up the user interface.

Defining Components
~~~~~~~~~~~~~~~~~~~

Components are defined using
`ES6 classes <http://es6-features.org/#ClassDefinition>`_ and the
`React prop-type module <https://reactjs.org/docs/typechecking-with-proptypes.html>`_
for property validation.

User interface actions that require
application state changes should fire Reflux actions. Component state
changes force the component to re-render. Styles should be imported
from a local ``.less`` file with the same filename as the component.

|compass| uses the Node package
`classnames <https://www.npmjs.com/package/classnames>`_ to provide
class names to components.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      import React, { Component } from 'react';
      import PropTypes from 'prop-types';
      import classnames from 'classnames';

      import styles from './my-component.less';

      class MyComponent extends Component {

        static propTypes = {
          editable: PropTypes.bool.isRequired
        };

        constructor(props) {
          super(props);
          this.state = { active: true };
        }

        handleClick() {
          this.setState({ active: !this.state.active });
        }

        render() {
           return (
            <div className={classnames(styles.root)}>
              <h2 className={classnames(styles.title)}>My Component</h2>
               <button
                className={classnames(styles.button)}
                 type="button"
                disabled={this.props.editable}
                 onClick={this.handleClick.bind(this)}
               >
                 {this.state.active ? "Active" : "Inactive"}
             </button>
            </div>
          );
         }
       }

       export default MyComponent;
       export { MyComponent };

Registering Components
~~~~~~~~~~~~~~~~~~~~~~

To allow a plugin to use a component from another plugin or register
one of its own components for other plugins to use, the component must
be added to the application registry in ``./src/index.js``.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      import MyComponent from './plugin';

      const activate(appRegistry) => {
        appRegistry.registerComponent('MyPlugin.MyComponent', MyComponent);
      };

|compass| Application Registry
------------------------------

The *application registry* is the object that holds all of the plugin's
:ref:`stores <plugins-stores>`, :ref:`actions <plugins-actions>`,
:ref:`components <plugins-components>` and
:ref:`roles <plugins-roles>`.

The registry is globally available to all plugins by calling
``global.hadronApp.appRegistry``.

Lifecycle Hooks
---------------

The following section outlines the lifecycle stages of a |compass| Plugin
in the context of the application registry:

Activation
~~~~~~~~~~

When a plugin first loads, |compass| calls the ``activate`` method in the
plugin's root ``index.js`` file. This is where the plugin registers
various objects with the application registry so they may be
potentially consumed by other plugins.

The following is an example from the query bar plugin:

.. cssclass:: copyable-code
.. code-block:: javascript

   const activate(appRegistry) => {
      appRegistry.registerComponent('Query.QueryBar', QueryBarComponent);
      appRegistry.registerComponent('Query.SamplingMessage', SamplingMessage);
      appRegistry.registerAction('Query.Actions', QueryAction);
      appRegistry.registerStore('Query.Store', QueryStore);
      appRegistry.registerStore('Query.ChangedStore', QueryChangedStore);
    };

When plugin activation is completed, the application registry is also
passed to any :ref:`store <plugins-stores>` in the registry containing
an ``onActivated`` method. This guarantees that all pieces of the
plugin have been registered before any plugin tried to pull another
item from the registry.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const MyPluginStore = Reflux.createStore({

         onActivated: function(appRegistry) {
           // Do potential stuff here.
         }
       });

Everything registered in the application registry is available for use
by other plugins. For example, a plugin could listen for query changes
and perform some action in response:

.. cssclass:: copyable-code
.. code-block:: javascript

   const MyPluginStore = Reflux.createStore({

      onActivated: function(appRegistry) {
        appRegistry.getStore('Query.ChangedStore').listenTo(this.handleQueryChange.bind(this));
      },

      handleQueryChange: function(query) {
         debug(query.filter);
         debug(query.project);
         debug(query.sort);
         debug(query.skip);
         debug(query.limit);
       }
   });

Connection
~~~~~~~~~~

Plugins can also hook into the connection lifecycle to know when the
data service has established a connection to the server and is ready to
accept requests. Plugins that access the data service directly need to
implement this method.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const PingStore = Reflux.createStore({

         onActivated(appRegistry) {
           appRegistry.on('data-service-connected', this.onConnected.bind(this));
         },

         onConnected: function((error, dataService)) {
           if (!error) {
             dataService.command({ ping: 1 }, (err, result) {
               if (!err) {
                 this.trigger(result);
               }
             });
           }
         },
      });

Query Changes
~~~~~~~~~~~~~

The ``onQueryChanged`` method is called on all registered stores when
the |compass| query has been changed and executed. The query object
passed to the method includes the following fields:

- Filter
- Project
- Sort
- Skip
- Limit

For details on these fields, see :doc:`Query Bar </query-bar>`.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const QueryListenerStore = Reflux.createStore({

         onActivated(appRegistry) {
           appRegistry.on('query-applied', this.onQueryChanged.bind(this));
         },

         onQueryChanged: function(query) {
           const projection = query.project;
           const sort = query.sort;
           ...
         }
      });


Namespace Changes
~~~~~~~~~~~~~~~~~

Plugins that need to be informed of namespace changes can implement
namespace lifecycle methods on :ref:`stores <plugins-stores>` that are
registered with the application registry. The full namespace is passed
to the function.

.. example::

   .. cssclass:: copyable-code
   .. code-block:: javascript

      const NameStore = Reflux.createStore({

         onCollectionChanged: function(ns) {
           this.setState({'namespace': ns});
         },
         onDatabaseChanged: function(ns) {
           this.setState({'namespace': ns});
         }
      });

Styling
-------

With the new web-pack enabled plugin model (v1.0.0+), |compass| plugins
implement `CSS Modules <https://github.com/css-modules/css-modules>`_
and `Less syntax <http://lesscss.org/>`_ to add styling to components.

Styles are scoped locally to a component. Style definitions exist
directly next to a component's implementation. See the following
file structure for details:

.. code-block:: none

   components
   └── my-component
        ├── index.js
        ├── my-component.jsx - React implementation of the component.
        ├── my-component.less - Styles for this component.
        ├── my-component.stories.js
        └── my-component.spec.js

For a component with the name ``MyComponent``, the directoy is called
``my-component``, and the style file inside this directory is
``my-component.less``.

Example
~~~~~~~

Consider the following implementation of a component called
``MyComponent``:

.. cssclass:: copyable-code
.. code-block:: javascript

   import React, { Component } from 'react';
   import PropTypes from 'prop-types';
   import classnames from 'classnames';

   import styles from './my-component.less';

   class MyComponent extends Component {

     render() {
       return (
         <div className={classnames(styles.root)}>
           <h2 className={classnames(styles.title)}>This is a title.</h2>
         </div>
       );
     }
   }

   export default MyComponent;
   export { MyComponent };

This component might have styles defined in ``my-component.less`` in
the following manner:

.. cssclass:: copyable-code
.. code-block:: css

   .root {
      background: #0e83cd;
      color: #fff;
      height: 100vh;
      padding: 2.4rem;
    }

    .title {
      margin-top: 0;
   }

Notice how the style file is imported at the top of the implementation
file. This ``root`` and ``title`` elements are then accessible as keys
in the styles object in the ``.less`` file.

Together with the
`classnames <https://www.npmjs.com/package/classnames>`_ helper
package, these keys can be passed as class names to the DOM elements
as in the following example:

.. code-block:: html

   <div className={classnames(styles.title)}>...</div>

This code generates a DOM element with the following style class:

.. code-block:: html

   <div class=".MyPlugin_my-component-title__2Nklg">...</div>

Notice that this element has the plugin name prefixed, followed by the
block component (in this case ``my-component``), then the element (in
this case ``-title``), and finally a unique hash suffix to guarantee
uniqueness. This hash guarantees uniqueness across different plugins.

.. note::

   In general, developers do not have to worry about the generated
   class name.

Using Classnames for Cleaner Class Name Construction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `classnames <https://www.npmjs.com/package/classnames>`_ package
allows elegant string construction for complex class names.

To see how complex dynamic class names can be generated in ReactJS, see
`this example <https://www.npmjs.com/package/classnames#usage-with-reactjs>`_.

